{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AlphaCodium","text":"<p>Code Generation with AlphaCodium: From Prompt Engineering to Flow Engineering.</p> <p>Paper | Dataset</p> <p>Official Implementation:</p> <p>Tal Ridnik, Dedy Kredo, Itamar Friedman</p>"},{"location":"#abstract","title":"Abstract","text":"<p>Code generation problems differ from common natural language problems - they require matching the exact syntax of the target language, identifying happy paths and edge cases, paying attention to numerous small details in the problem spec, and addressing other code-specific issues and requirements. Hence, many of the optimizations and tricks that have been successful in natural language generation may not be effective for code tasks.</p> <p>In this work, we propose a new approach to code generation by LLMs, which we call AlphaCodium - a test-based, multi-stage, code-oriented iterative flow, that improves the performances of LLMs on code problems.</p> <p>We tested AlphaCodium on a challenging code generation dataset called CodeContests, which includes competitive programming problems from platforms such as Codeforces. The proposed flow consistently and significantly improves results. On the validation set, for example, GPT-4 accuracy (pass@5) increased from 19% with a single well-designed direct prompt to 44% with the AlphaCodium flow. </p> <p>Many of the principles and best practices we acquired in this work, we believe, are broadly applicable to general code generation tasks.</p> <p> </p>"},{"location":"#installation","title":"Installation","text":"<ol> <li> <p>setup a virtual environment and run: <code>pip install -r requirements.txt</code></p> </li> <li> <p>Duplicate the file <code>alpha_codium/settings/.secrets_template.toml</code>, rename it as <code>.secrets.toml</code>, and fill in your OpenAI API key: <pre><code>[openai]\nkey = \"...\"\n</code></pre></p> </li> <li> <p>Download the processed CodeContest validation and test dataset from hugging face, extract the zip file, and placed the extracted folder in the root of the project.</p> </li> </ol>"},{"location":"#how-to-run","title":"How to run","text":""},{"location":"#configuration","title":"Configuration","text":"<p>The file: <code>alpha_codium/settings/configuration.toml</code> contains the configuration for the project. In the <code>config</code> section you can choose the model you want to use (\"gpt-4\", \"gpt-3.5-turbo-16k\", or others).</p>"},{"location":"#solving-a-specific-problem","title":"Solving a specific problem","text":"<p>To solve a specific problem with AlphaCodium, from the root folder run: <pre><code>python -m alpha_codium.solve_problem \\\n--dataset_name /path/to/dataset \\\n--split_name test \\\n--problem_number 0\n</code></pre> - The <code>dataset_name</code> is the path to the dataset folder you downloaded in the installation step.</p> <ul> <li> <p>Note that the validation set contains 117 problems, and the test set contains 165 problems, so the <code>problem_number</code> parameter should be accordingly (zero-based)</p> </li> <li> <p>The <code>split_name</code> can be either <code>valid</code> or <code>test</code>.</p> </li> <li> <p>The following sections in the configuration file:  <code>solve</code>, <code>self_reflection</code>,<code>possible_solutions</code>,<code>generate_ai_tests</code>,<code>initial_code_generation</code>,<code>public_tests</code>, <code>ai_tests</code>  enable to adjust possible configurations for the different stages of the flow.</p> </li> <li> <p>Each run logs the results to a file named <code>alpha_codium/example.log</code>. Reviewing the log file is a good way to understand what is going on in each stage of the flow.</p> </li> </ul> <p></p>"},{"location":"#solving-the-entire-dataset","title":"Solving the entire dataset","text":"<p>to solve the entire dataset with AlphaCodium, from the root folder run: <pre><code>python -m alpha_codium.solve_dataset \\\n--dataset_name /path/to/dataset \\\n--split_name test\n--database_solution_path /path/to/output/dir/dataset_output.json\n</code></pre></p> <ul> <li>The <code>split_name</code> can be either <code>valid</code> or <code>test</code>.</li> <li><code>database_solution_path</code> is the path to the directory where the solutions will be saved.</li> <li>The <code>dataset</code> section in the configuration file contains the configuration for the running and evaluation of a dataset.</li> <li>Note that this is a long process, and it may take a few days to complete with large models (e.g. GPT-4) and several iterations per problem. </li> <li><code>dataset.num_iterations</code> defines the number of iterations for each problem (pass@K). For a large number of iterations, it is recommended to introduce some randomness and different options for each iteration to achieve top results.</li> </ul>"},{"location":"#running-the-evaluation","title":"Running the evaluation","text":"<p>Once you generate a solution for the entire dataset (valid or test), you can evaluate it by running: <pre><code>python -m alpha_codium.evaluate_dataset\\\n--dataset_name /path/to/dataset\\\n--split_name test\\\n--database_solution_path /path/to/output/dir/dataset_output.json\n</code></pre></p>"},{"location":"#technical-qa","title":"Technical Q&amp;A","text":"<p>Aggregating some technical questions we received about this project:</p> <p>Q: How much time did you spend on \"prompt engineering\" compared to \"flow engineering\"?</p> <p>A: Structured output almost completely eliminates the need for simple prompt engineering. We estimate that ~95% of the time we did more high-level design, reasoning, and injecting data at the correct places, ..., a.k.a. \"flow engineering\".</p> <p>Q: How do you know that there wasn't a data leakage? </p> <p>A: The test set of CodeContests dataset comprises problems published after September 2021, while the GPT-4 model variant we used (gpt-4-0613) has a data cutoff of September 2021. Hence, there is no data leakage for GPT4, on the test set. For other models like DeepSeek, we cannot be sure. However, note that our main result is a comparison of \"direct prompt\" vs. \"AlphaCodium flow\". Data leakage would help both approaches, so the relative improvement of AlphaCodium flow is still valid.</p> <p>Q: Is this project relevant only to specific programming languages?</p> <p>A: No. The proposed flow is language agnostic. We generated solutions in Python, but the flow can be applied to any language.</p> <p>Q: How did you manage the context window? </p> <p>A: We used models with a context window of 8192 tokens, and we did not encounter cases where it did not suffice. However, we clearly observed that as the context we used in practice grows larger (let's say, above 4000 tokens), the model starts to \"ignore\" some of the information in the context. Hence, there is a clear tradeoff: - Injecting the results of previous stages into the context, may help the model to generate better code. - However, it may also cause the model to ignore specific details and nuances from the problem description.</p> <p>Q: Is this work \"realistic\" in terms of the number of LLM calls? </p> <p>A: In comparison to AlphaCode, we do four orders of magnitude (!) fewer calls (per solution AlphaCodium does 15-20 calls). Yet we acknowledge that for some applications, this may still be too much, and more optimizations are needed. We however believe that many of the ideas and principles we acquired in this work are broadly applicable, even when the number of calls is further limited.</p> <p>Q: Why do you iterate only on the generated code, and not on the AI-generated tests?</p> <p>A: For code problems in CodeContests, the tests are a list of input-output pairs. Hence, you don't really learn anything new when you \"fix\" a test - you just change its output to the prediction of the generated code. Instead of fixing tests, we preferred to always try and fix the code, while using \"test anchors\". (see the paper for more details). However, for other code generation tasks, where the tests are more complex and contain runnable code, iterating on the tests, in addition to iterating on the generated code, may be beneficial.</p>"},{"location":"#broader-applicability","title":"Broader Applicability","text":"<p>While this work presents results on CodeContests dataset, we believe that it has a broader applicability.</p> <p>First and foremost, we feel that the proposed AlphaCodium flow, with reasonable adjustments, can be used as a more general framework for other code generation tasks.</p> <p>Secondly, many of the design concepts, principles, and tricks we acquired in this work are broadly applicable as-is to any general code generation tasks. For example: - YAML Structured output: asking the model to generate an output in YAML format, equivalent to a given Pydantic class</p> <ul> <li> <p>Semantic reasoning via bullet points analysis: Bullet points analysis encourages an in-depth understanding of the problem, and forces the model to divide the output into logical semantic sections, leading to improved results</p> </li> <li> <p>LLMs do better when generating a modular code: when asking the model to: <code>divide the generated code into small sub-functions, with meaningful names and functionality</code>, we observe a better-produced code, with fewer bugs, and higher success rates for the iterative fixing stages.</p> </li> <li> <p>Soft decisions with double validation: with a double validation process, we add an extra step where, given the generated output, the model is asked to re-generate the same output, but correct it if needed</p> </li> <li> <p>Leave room for exploration: since the model can be wrong, it\u2019s better to avoid irreversible decisions, and leave room for exploration and code iterations with different possible solutions</p> </li> </ul> <p>The list above is partial. See the paper for more details. The code provided in the repo can be used as a reference for better understanding the proposed concepts, and for applying them to other code generation tasks.</p>"},{"location":"#example-problem","title":"Example Problem","text":"<p>In this section, we present an example for a full problem from CodeContests dataset (test-set, problem 1), in order to demonstrate the complexity of the problems in the dataset, and the challenges they pose to LLMs.</p> <pre><code>problem name: '1575_B. Building an Amusement Park'\n\nproblem description:\nMr. Chanek lives in a city represented as a plane. He wants to build an amusement park in the shape of a circle of radius r. \nThe circle must touch the origin (point (0, 0)).\nThere are n bird habitats that can be a photo spot for the tourists in the park. The i-th bird habitat is at point p_i = (x_i, y_i). \n\nFind the minimum radius r of a park with at least k bird habitats inside. \n\nA point is considered to be inside the park if and only if the distance between p_i and the center of the park is less than or equal \nto the radius of the park.\nNote that the center and the radius of the park do not need to be integers.\n\nIn this problem, it is guaranteed that the given input always has a solution with r \u2264 2 \u22c5 10^5.\n\nInput\n\nThe first line contains two integers n and k (1 \u2264 n \u2264 10^5, 1 \u2264 k \u2264 n) \u2014 the number of bird habitats in the city and the number of bird \nhabitats required to be inside the park.\nThe i-th of the next n lines contains two integers x_i and y_i (0 \u2264 |x_i|, |y_i| \u2264 10^5) \u2014 the position of the i-th bird habitat.\n\nOutput\n\nOutput a single real number r denoting the minimum radius of a park with at least k bird habitats inside. It is guaranteed that the given \ninput always has a solution with r \u2264 2 \u22c5 10^5.\nYour answer is considered correct if its absolute or relative error does not exceed 10^{-4}.\nFormally, let your answer be a, and the jury's answer be b. Your answer is accepted if and only if \\frac{|a - b|}{max{(1, |b|)}} \u2264 10^{-4}.\n\nExamples\n\nInput\n\n8 4\n-3 1\n-4 4\n1 5\n2 2\n2 -2\n-2 -4\n-1 -1\n-6 0\n\nOutput\n\n3.1622776589\n\n\nInput\n\n1 1\n0 0\n\n\nOutput\n\n0.0000000000\n\nNote\n\nIn the first example, Mr. Chanek can put the center of the park at (-3, -1) with radius \u221a{10} \u2248 3.162. It can be proven this is the minimum r.\n</code></pre>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>Our process CodeContests dataset is based on the original CodeContests dataset. We removed the train set (which is not relevant to our work) and did some post-processing and cleaning to the validation and test sets.</p>"},{"location":"#citation","title":"Citation","text":"<pre><code>@misc{ridnik2024code,\n      title={Code Generation with AlphaCodium: From Prompt Engineering to Flow Engineering}, \n      author={Tal Ridnik and Dedy Kredo and Itamar Friedman},\n      year={2024},\n      eprint={2401.08500},\n      archivePrefix={arXiv},\n      primaryClass={cs.LG}\n}\n</code></pre>"}]}